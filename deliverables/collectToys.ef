project: collect_toys
horizon: 20
discount: 0.97
#include <random>
 

define_type: tBall
variable: int location 
variable: float reward 
variable: string color

state_variable: tBall greenBall
code:
state.greenBall.color="green";

state_variable: tBall blueBall
code:
state.blueBall.color="blue";

state_variable: tBall blackBall
code:
state.blackBall.color="black";

state_variable: tBall toy4
code:
state.toy4.color="red";

state_variable: int nav_cnt
code:
state.nav_cnt=0;

state_variable: int pick_cnt
code:
state.pick_cnt=0;

state_variable: int robotLocation 
code:
state.robotLocation=4;
 
reward_code:
if(state.pick_cnt > 6 || state.nav_cnt > 8)
{
	__isGoalState =true;
	__reward=0;
}

// run on the 4 ball objects (for self I think adding Objects to the end of the type name is somehow making it a list)
if (state.greenBall.location == 4 && state.blueBall.location == 4 && state.blackBall.location == 4 && state.toy4.location == 4){
    __isGoalState =true;
	__reward=0;
}



initial_belief:


//sample ball locations
std::random_device rd;
std::mt19937 gen(rd());
vector<float> green_loc_w{0.1,0.05,0.8,0.05};
vector<float> blue_loc_w{0.7,0.1,0.1,0.1};
vector<float> black_loc_w{0,0,0,0};

// green
std::discrete_distribution<> loc_dist_green(green_loc_w.begin(), green_loc_w.end());
int selected_loc_green = loc_dist_green(gen);
state.greenBall.location =  selected_loc_green;

//blue
float compensation = blue_loc_w[selected_loc_green]/3;
for(int i=0;i<4;i++){
	if(i == selected_loc_green){
		blue_loc_w[i]=0;
	}
	else{
		blue_loc_w[i]+= compensation;
	}
}

std::discrete_distribution<> loc_dist_blue(blue_loc_w.begin(), blue_loc_w.end());
int selected_loc_blue= loc_dist_blue(gen);
state.blueBall.location =  selected_loc_blue;

// black
for(int i=0;i<4;i++){
	if (!(i == selected_loc_green || i == selected_loc_blue)){
		black_loc_w[i]=0.5;
	}
}
std::discrete_distribution<> loc_dist_black(black_loc_w.begin(), black_loc_w.end());
int selected_loc_black= loc_dist_black(gen);
state.blackBall.location =  selected_loc_black;

// red - takes what left
for(int i=0;i<4;i++){
	if (!(i == selected_loc_green || i == selected_loc_blue || i == selected_loc_black)){
		int selected_loc_red = i;
		state.toy4.location = selected_loc_red ;
	}
}
        
// sample ball rewards (playtimes)

//set playtime selection chance for each ball (playtime is the reward)
vector<float> rewards{40,20,15,15};
vector<float> green_pt_w{0.8,0.05,0.1,0.05};
vector<float> blue_pt_w{0.1,0.7,0.1,0.1};
vector<float> black_pt_w{0,0,0,0};

// green
std::discrete_distribution<> pt_dist_green(green_pt_w.begin(), green_pt_w.end());
int selected_pt_idx_green= pt_dist_green(gen);
state.greenBall.reward=  rewards[selected_pt_idx_green];

//blue
compensation = blue_pt_w[selected_pt_idx_green]/3;
for(int i=0;i<4;i++){
	if(i == selected_pt_idx_green){
		blue_pt_w[i]=0;
	}
	else{
		blue_pt_w[i]+= compensation;
	}
}

std::discrete_distribution<> pt_dist_blue(blue_pt_w.begin(), blue_pt_w.end());
int selected_pt_idx_blue= pt_dist_blue(gen);
state.blueBall.reward=  rewards[selected_pt_idx_blue];
        
// black
for(int i=0;i<4;i++){
	if (!(i == selected_pt_idx_green || i == selected_pt_idx_blue)){
		black_pt_w[i]=0.5;
	}
}
std::discrete_distribution<> pt_dist_black(black_pt_w.begin(), black_pt_w.end());
int selected_pt_idx_black= pt_dist_black(gen);
state.blackBall.reward =  rewards[selected_pt_idx_black];

// red
// red - takes what left
for(int i=0;i<4;i++){
	if (!(i == selected_pt_idx_green || i == selected_pt_idx_blue || i == selected_pt_idx_black)){
		int selected_pt_idx_red = i;
		state.toy4.reward= rewards[selected_pt_idx_red] ;
	}
}


